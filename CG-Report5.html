<!DOCTYPE html>
<html lang="ja">
  <head>

    <meta charset="utf-8" />
    <script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
    <script>
      // ページの読み込みを待つ
      window.addEventListener('load', init);
      var F1 = 0;
      var F2 = 0;
      var F3 = 0;
      function init() {
        // サイズを指定
        const width = 960;
        const height = 540;

        // レンダラーを作成
        const renderer = new THREE.WebGLRenderer({
          canvas: document.querySelector('#myCanvas')
        });
        //document.body.appendChild(renderer.domElement);
        renderer.setSize(width, height);
        // 背景の色を設定
        renderer.setClearColor(0x281a14);

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成
        const camera = new THREE.PerspectiveCamera(45, width / height);
        // カメラの初期座標を設定
        camera.position.set(0, 500, 1000);

        // カメラコントローラーを作成
        const controls = new THREE.OrbitControls(camera,document.body);
  
        // 平行光源1
        var directionalLight1 = new THREE.DirectionalLight(0xffffff);
        directionalLight1.position.set(100, 100, 100);
        // シーンに追加
        scene.add(directionalLight1);
        // 平行光源2
        var directionalLight2 = new THREE.DirectionalLight(0xffffff);
        directionalLight2.position.set(-100, 100, 100);
        // シーンに追加
        scene.add(directionalLight2);

        var directionalLight3 = new THREE.DirectionalLight(0xffffff);
        directionalLight3.position.set(0, -100, -100);
        // シーンに追加
        scene.add(directionalLight3);


        // helper
      /*const gridHelper = new THREE.GridHelper(200,50); // size, step
      scene.add(gridHelper);

      const axisHelper = new THREE.AxisHelper(200,50);
      scene.add(axisHelper);*/

        const conegeometry = new THREE.ConeGeometry( 5, 20, 32 );
        const boxgeometry = new THREE.BoxGeometry( 5, 5, 5 );
        const material = new THREE.MeshPhongMaterial( {color: 0xFF0000} );
        const material_Bl = new THREE.MeshPhongMaterial( {color: 0x000000} );
        const material_BLUE = new THREE.MeshPhongMaterial( {color: 0x4c6cb3} );
        const body1_G1 = new THREE.Mesh( conegeometry, material );
        scene.add( body1_G1 );
        body1_G1.scale.set(30,30,15);
        body1_G1.position.set(0, 100, 0);

        const cylindergeometry = new THREE.CylinderGeometry(5, 10, 20, 20);

        const body2_G1 = new THREE.Mesh( cylindergeometry, material );
        scene.add( body2_G1 );
        body2_G1.scale.set(6,20,10);
        body2_G1.rotation.y = 3.14/2;
        body2_G1.position.set(0, 200, 0);

        const jet1_G1 = new THREE.Mesh( cylindergeometry, material_Bl );
        scene.add( jet1_G1 );
        jet1_G1.scale.set(4,4,4);
        jet1_G1.rotation.y = 3.14/2;
        jet1_G1.position.set(150, -200, 0);

        const jet2_G1 = new THREE.Mesh( cylindergeometry, material_Bl );
        scene.add( jet2_G1 );
        jet2_G1.scale.set(4,4,4);
        jet2_G1.rotation.y = 3.14/2;
        jet2_G1.position.set(-150, -200, 0);

        const wingR_G1 = new THREE.Mesh( conegeometry, material );
        scene.add( wingR_G1 );
        wingR_G1.scale.set(56,14, 2);
        wingR_G1.rotation.z = 3.14/2+3.14/4;
        wingR_G1.position.set(60, 50, 0);

        const wingL_G1 = new THREE.Mesh( conegeometry, material );
        scene.add( wingL_G1 );
        wingL_G1.scale.set(56,14, 2);
        wingL_G1.rotation.z = -3.14/2-3.14/4;
        wingL_G1.position.set(-60, 50, 0);

        const wingT_G1 = new THREE.Mesh( conegeometry, material );
        scene.add( wingT_G1 );
        wingT_G1.scale.set(25,7, 2);
        wingT_G1.rotation.y = -3.14/2;

        wingT_G1.position.set(0, -130, 80);

        const back_g = new THREE.SphereGeometry(7, 12, 8, Math.PI * 0.25, Math.PI * 1.5, Math.PI * 0.25, Math.PI * 0.5);
        const back1_G1 = new THREE.Mesh( back_g, material );
        scene.add( back1_G1 );
        back1_G1.scale.set(20,35, 10);
        back1_G1.rotation.z = 3.14/2;
        back1_G1.position.set(-150, -180, 0);

        const back2_G1 = new THREE.Mesh( back_g, material );
        scene.add( back2_G1 );
        back2_G1.scale.set(20,35, 10);
        back2_G1.rotation.z = 3.14/2;
        back2_G1.position.set(150, -180, 0);

        const back3_G1 = new THREE.Mesh( boxgeometry, material );
        scene.add( back3_G1 );
        back3_G1.scale.set(20,100, 20);
        back3_G1.rotation.z = 3.14/2;
        back3_G1.position.set(0, -180, 0);

        const GetterE = new THREE.Group()
        GetterE.add(jet1_G1, jet2_G1, back1_G1, back2_G1, back3_G1, body1_G1, body2_G1, wingL_G1, wingR_G1, wingT_G1);
        GetterE.position.set(100, 500, 0);
        GetterE.rotation.z = 3.14/2;
        GetterE.rotation.x = 3.14+3.14/2;
        GetterE.scale.set(0.8,1,0.8)
        scene.add(GetterE);

        const material_GJ = new THREE.MeshPhongMaterial( {color: 0x95949a} );
        const body1_G2 = new THREE.Mesh( conegeometry, material_GJ );
        scene.add( body1_G2 );
        body1_G2.scale.set(35,30,20);
        body1_G2.position.set(0, 100, 0);

        const body2_G2 = new THREE.Mesh( cylindergeometry, material_GJ );
        scene.add( body2_G2 );
        body2_G2.scale.set(10,20,20);
        body2_G2.rotation.y = 3.14/2;
        body2_G2.position.set(0, 0, 0);

        const bodyGJ = new THREE.SphereGeometry(7, 12, 8);

        const body3_G2 = new THREE.Mesh( bodyGJ, material_GJ );
        scene.add( body3_G2 );
        body3_G2.scale.set(6,14.5, 7.2);
        body3_G2.rotation.z = 3.14/2;
        body3_G2.position.set(0, 190, 0);

        const body4_G2 = new THREE.Mesh( bodyGJ, material_BLUE );
        scene.add( body4_G2 );
        body4_G2.scale.set(14.5,6, 5);
        body4_G2.rotation.z = 3.14/2;
        body4_G2.position.set(100, 80, 0);

        const body5_G2 = new THREE.Mesh( bodyGJ, material_BLUE );
        scene.add( body5_G2 );
        body5_G2.scale.set(14.5,6, 5);
        body5_G2.rotation.z = 3.14/2;
        body5_G2.position.set(-100, 80, 0);

        const back1_G2 = new THREE.Mesh( back_g, material_GJ );
        scene.add( back1_G2 );
        back1_G2.scale.set(40,40,15);
        back1_G2.rotation.z = 3.14/2;
        back1_G2.position.set(0, -200, 0);

        const jet1_G2 = new THREE.Mesh( cylindergeometry, material_Bl );
        scene.add( jet1_G2 );
        jet1_G2.scale.set(4,4,4);
        jet1_G2.rotation.y = 3.14/2;
        jet1_G2.position.set(100, -200, 0);

        const jet2_G2 = new THREE.Mesh( cylindergeometry, material_Bl );
        scene.add( jet2_G2 );
        jet2_G2.scale.set(4,4,4);
        jet2_G2.rotation.y = 3.14/2;
        jet2_G2.position.set(-100, -200, 0);

        const wingR_G2 = new THREE.Mesh( conegeometry, material_GJ );
        scene.add( wingR_G2 );
        wingR_G2.scale.set(5,10, 1.5);
        wingR_G2.rotation.z = 3.14;
        wingR_G2.position.set(20, 220, 0);

        const wingL_G2 = new THREE.Mesh( conegeometry, material_GJ );
        scene.add( wingL_G2 );
        wingL_G2.scale.set(5,10, 1.5);
        wingL_G2.rotation.z = -3.14;
        wingL_G2.position.set(-20, 220, 0);
        
        const cockpit_G2 = new THREE.Mesh( boxgeometry, material_GJ );
        scene.add( cockpit_G2 );
        cockpit_G2.scale.set(10,15,5);
        cockpit_G2.position.set(0, 30, 70);

        const GetterJ = new THREE.Group()
        GetterJ.add(jet1_G2, jet2_G2, back1_G2,body1_G2, body2_G2, body3_G2, body4_G2, body5_G2,wingL_G2, wingR_G2, cockpit_G2);
        GetterJ.position.set(800, 500, 0);
        GetterJ.rotation.z = 3.14/2;
        GetterJ.rotation.x = 3.14+3.14/2;
        scene.add(GetterJ);


        tick();
        // 毎フレーム時に実行されるループイベントです
        function tick() {
          // レンダリング
          renderer.render(scene, camera);
          requestAnimationFrame(tick);
          
          }
      }
    </script>
  </head>
  <body>
    <h1>打ち上げ花火はどこから見ても同じ</h1>
    <canvas id="myCanvas"></canvas>
    <p>本課題では、ビルボードで花火を再現した。</p>
  </body>
</html>
